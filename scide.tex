\documentclass[11pt,a4paper]{article}
\usepackage{lac2013}
\sloppy
\newenvironment{contentsmall}{\small}

\title{SuperCollider IDE: A Dedicated Integrated Development Environment for SuperCollider code}

%see lac2012.sty for how to format multiple authors!
\author
{
Jakob LEBEN
\\ Koper, Slovenia
\\ jakob.leben@gmail.com
\And
Tim Blechmann
\\ Vienna, Austria
\\ tim@klingt.org
}


\hyphenation{MacOS}
\hyphenation{scsynth}
\hyphenation{sclang}

\begin{document}
\maketitle


\begin{abstract}
\begin{contentsmall}
In short: $SuperCollider_{2013} = kick\{ass\}$
\end{contentsmall}
\end{abstract}

\keywords{
\begin{contentsmall}
SuperCollider
\end{contentsmall}
}

\section{Introduction}

SuperCollider \cite{rethinking-sc} is a computer music system that was originally developed by James McCartney in the
1990s for MacOS and has been ported to Linux and eventually Windows after it was open sourced in the early 2000s. It is
a modular system based on an object oriented programming language (sclang) and a separate audio synthesis server
(scsynth)\footnote{A multiprocessor-aware alternative to scsynth is supernova \cite{blechmann11icmc}}.


\subsection{History of SuperCollider and its Code Editing Environments}

SuperCollider is heavily influenced by Smalltalk and was originally using a similar programming model: it strongly
coupled the interpreter with the development environment. This integrated programming environment \textbf{SC.app} was
written for MacOSX using the Cocoa framework and therefore was not portable to other platforms. It provides both a
development environment and an implementation of GUI widgets.

When porting SuperCollider to Linux, Stefan Kersten implemented \textbf{scel}, a SuperCollider editor mode for Emacs
\cite{collision}, which had been the most feature-rich editor for SuperCollider for a long time, as it not only
supported syntax highlighting, but also some introspection, a limited form of call hints and support for the old
HTML-based help system.

At the moment, two other SuperCollider modes have been part of the official distribution: \textbf{scvim} (for vim) or
\textbf{sced} (for gedit). Before writing the new SuperCollider IDE, one of the authors of this paper
wrote an editor mode for Kate (\textbf{scate}). Apart from that, there were other editors or editor modes,
\textbf{scfront} (a Tcl/Tk based editor), \textbf{qcollider} (a Qt-based editor) and modes for the squeak Smalltalk
environment, the TextMate editor, Eclipse and probably others \cite{collision}. For the Windows port of SuperCollider, a
python-based editor called \textbf{PsyCollider} had first been developed \cite{dos}, but was later removed from
SuperCollider distribution as the code was unmaintained, unstable and finally made obsolete when gedit and sced were
ported to Windows.

\subsection{Motivation for new IDE}

Having multiple editors or programming environments for SuperCollider has numerous disadvantages:

\begin{itemize}
\item The user experience vastly differs among the different programming environments.
\item Each programming environment has to be maintained separately, and long-term maintenance turned out to be a
  problem. The scarce development resources are spread among different projects instead of focused on a single system.
\item No existing environment is working out of the box on every supported operating system.
\item Some environments (e.g. scvim or scel) are based on editors that are not very accessible for beginners.
\end{itemize}

In late 2011 the authors therefore decided to start the development of a new IDE dedicated to SuperCollider (not
merely an editor mode). The main motivation was to provide an IDE that would offer a unified user experience across all
supported platforms and that would be both easy to use for beginners and powerful so that experienced users don't feel the
need to switch to an advanced editor like Emacs.

Since Jakob had already implemented the GUI widgets of sclang in Qt to make them cross-platform, the choice of GUI
framework for the new IDE was clear.

\section{Basic architecture}

Since an IDE demands a tight integration with the target programming language, the question was
raised immediately whether the new IDE should be coupled with the language interpreter into one
process, as is the case in SC.app, or rather a separate process, as in existing editor modes.

Consideration of benefits and drawbacks of the two options brought decision in favor of
separating the IDE from the interpreter: the most important benefit of this strategy is that the
decoupling allows the IDE to survive potential crashes of the interpreter, and maintain
responsiveness and control in case running some SuperCollider code locks up in an infinite loop.

The major drawback of decoupling is increased effort for inter-process communication (IPC) with the
interpreter. However, scel has proved that a powerful set of features may be built on top of IPC,
and hence this did not outweight the benefits of decoupling.

\section{Code editing}

It is our goal for SuperCollider IDE to implement code-editing assistance on the level of support
that general-purpose IDEs offer for most widely used programming languages. Namely,
we consider the crucial features: syntax highlighting, autocompletion and method call hints.

\subsection{Syntax highlighting}

Existing SuperCollider editor modes typically reuse generic support of their host editors for
on-the-fly syntax highlighting. SC.app, albeit the oldest and most widely used environment, only
updates highlighting on explicit request via the user interface.

Syntax highlighting in SuperCollider IDE has been implemented to update on-the-fly, and in a very
efficient manner to never interfere with code typing. Attention was paid to strictly match the
lexical rules obeyed by the SuperCollider language compiler. As a result, we have most efficient and
correct syntax highlighting for SuperCollider language to-date.

\subsection{Autocompletion}

Automatic code completion (autocompletion) consists of offering the user a selection of possible
continuations of text being typed, based on context.

As a weakly-typed programming language, SuperCollider poses limitations on the possibilities of
autocompletion, compared to strongly-typed languages (e.g. C, C++). Namely, it is not always
possible to infer the type of a variable identifier, and hence the set of its methods. We have
worked in SuperCollider IDE towards offering completion as far as possible within these limitations.

Autocompletion is offered in the following cases:
\begin{itemize}
 \item Class names:
 
 \verb|Sin<...>|
 
 Since class names exclusively begin with an uppercase letter, it is straightfoward
 to complete them from the set of all classes.
 
 \item Method names following class names:
 
 \verb|Array.<...>|
 
 They are completed from the set of class methods of the
 readily-available class.
 
 \item Method names following literals and built-ins
 
 \verb|123.<...>|
 
 \verb|topEnvironment.<...>|
 
 They are completed from the set of instance methods of the class
 inferred from the literal or the built-in.
 
 \item Method names following a variable name:
 
 \verb|func.<...>|
 
 The class is not inferred, so the method is completed from the set of all methods of all classes.
 
\end{itemize}

Completion of methods of known classes starts immediately when the dot `.' is typed. One exception
to this is the case of methods of Integer literals: it only begins after 1 character has been
typed, or else redundant completion would be triggered on a dot in a Float literal, which proved
to be a rather annoying experience.

In other cases the list of candidates may be quite large (the set of all classes, or all methods of
all classes), hence completion only starts after 3 characters have been typed.

Although the current code base would easily support completion of built-ins (e.g.
\verb|topEnvironment|) and method names in functional notation (e.g. \verb|min(1,2)|) we have
decided to avoid that. The reason is that, formally, those cases would compete with other cases for
which we currently do not offer completion: e.g. variable names in scope. It has been argued that
completion may be understood (especially by novices) as the set of all and the only allowed options,
and hence misleading when incomplete.

The completion menu is hidden if the currently typed text matches one of the options exactly. In
that case, the user's intention has likely been met, so the menu would only present an obstacle to
changing activity: evaluating code, moving to another position in code, etc. However, this has been
a point of debate, as it would be possible to automatically detect the change of activity and close
the menu.

Although different aspects of usability often demand trade-offs, we will continue to refine the
behavior so as to maximize usefulness and intuitivity of autocompletion.

As already noted, there is potential to improve the domain of autocompletion to include:
\begin{itemize}
 \item Variables in scope:
 
 \verb|var abcdef; abc<...>|
 
 \item Inferring class of Array and Event literals:
 
 \verb|[1,2,3].<...>|
 
 \verb|(freq: 321).<...>|
 
 \item Inferring class of variables by assignment
 
 \verb|x = [1,2,3]; x.<...>|
 
\end{itemize}

\subsection{Method call assistance}

Method call assistance involves displaying a list of argument names and their default values, to aid
entering expressions for arguments in a method call.

It is implemented both for receiver notation as well as functional notation. In functional notation,
an argument is prepended to denote the receiver of the message.

The assistance is invoked when a relevant opening bracket `(' is typed, or a comma `,' is typed to
separate arguments, and additionally with a keyboard shortcut when the text cursor is anywhere
within the brackets surrounding the arguments.

This assistance is subject to the same limitations as autocompletion, due to a weakly-typed
language: to disambiguate the method, its owner class must be known. However, we have found a
pragmatic solution: where the class can not be inferred, we let the user pick a class via a pop-up
menu.

Hence, the following examples will offer assistance directly:

\verb|SinOsc.ar(|

\verb|123.forBy(|

...while the following will first display a list of classes that implement the method, then offer
method call assistance once a class is selected:

\verb|min(|

\verb|x.play(|

\verb|[1,2,3].inject(|

There is one special case in SuperCollider language where the method name is not explicit, namely
an opening bracket immediately following a class name:

\verb|Synth(|

In this case, the class method `new' is implied, and SuperCollider IDE takes this into account and
offers appropriate assistance.

Once the assistance is invoked, the name of the current argument being typed is highlighted, which
is of great help when the number of arguments is large, or the expression for an argument is very
long.

Moreover, one can quickly insert and cycle through available argument names with a press of the Tab
key, in order to realize argument addressing by name, as in:

\verb|SinOsc.ar(456, add: 1, mul:|

Once assistance has been activated for a particular method call, it remains active in the
background while assistance for a nested method call is being performed: when the user
finishes typing the inner call, assistance is automatically displayed for the outer call again.

This is especially useful in case assistance is based on explicit class selection (as explained
above) - the selection is remembered during nested assistances so that method disambiguation does
not need to be repeated.

As can be seen from examples above, this assistance would also benefit from increased ability to
automatically infer classes from text. Nevertheless, the described solution via explicit class
selection will remain to be useful where the intended method is absolutely ambiguous.


\section{Class library navigation}

Within the SuperCollider community, the border between system developers and users has always been
quite fuzzy. Furthermore, writing musical code often involves development of classes for purposes of
a specific musical task and for personal class libraries. Jumping from code that uses a class to
code that implements it is hence a frequent need.

The SuperCollider language interpreter has since the beginning featured introspection into where
each class and method is implemented, and referenced within the class library. Existing development
environments have already harnessed these capabilities to offer navigation between usage and
definition via GUI.

SuperCollider IDE attempts to exploit these capabilities in most practical ways. Handy shortcuts
will pop up a dialog that lists all methods whose name matches the text under cursor, or all methods
of the class under cursor. Pressing Return on an entry will open the file at position where the
selected method or class is implemented. The same dialog contains a search field which can be used
to search for any class or method.

An equivalent dialog is implemented also for class and method references: the listing contains
all methods that contain references to another class or method.


\section{Help}

Details about help integration.

\section{GUI}

\begin{itemize}
 \item largely unified look across platforms
 \item general: central editor area, docks, status bar
 \item document list
 \item editor: tabs, split views, line numbering, code evaluation + blinking
 \item find/replace, regexp
 \item command line
 \item post window
 \item help
 \item server and interpreter status
 \item shortcuts
\end{itemize}

\section{Configuration}

\begin{itemize}
 \item IDE config: behavior, colors, shortcuts, etc...
 \item language config
 \item startup file
\end{itemize}


\section{Future plans}

\begin{itemize}
 \item SCDoc syntax highlighting
 \item `Desk \& cards' idea: snippets of code visually and interactively separate
 \item Visual SynthDef composer
 \item Visual Pattern composer, visualizer (integrate AlgoScore?)
 \item More integration:
 \begin{itemize}
    \item more server controls
    \item  embeddable GUI components created \& controlled in sclang
    \item  scripting (sclang? other language?)
 \end{itemize}
 \item Improved looks, QML
\end{itemize}

\section{Conclusions}

Concluding text.

\section{Acknowledgements}

Our thanks go to \ldots .

\bibliographystyle{acl}
\bibliography{sample}

\end{document}
