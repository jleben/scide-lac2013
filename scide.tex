\documentclass[11pt,a4paper]{article}
\usepackage{lac2013}
\sloppy
\newenvironment{contentsmall}{\small}

\title{SuperCollider IDE: A Dedicated Integrated Development Environment for SuperCollider code}

%see lac2012.sty for how to format multiple authors!
\author
{
Jakob LEBEN
\\ Koper, Slovenia
\\ jakob.leben@gmail.com
\And
Tim Blechmann
\\ Vienna, Austria
\\ tim@klingt.org
}


\hyphenation{MacOS}
\hyphenation{scsynth}
\hyphenation{sclang}

\begin{document}
\maketitle


\begin{abstract}
\begin{contentsmall}
In short: $SuperCollider_{2013} = kick\{ass\}$
\end{contentsmall}
\end{abstract}

\keywords{
\begin{contentsmall}
SuperCollider
\end{contentsmall}
}

\section{Introduction}

SuperCollider \cite{rethinking-sc} is a computer music system that was originally developed by James McCartney in the
1990s for MacOS and has been ported to Linux and eventually Windows after it was open sourced in the early 2000s. It is
a modular system based on an object oriented programming language (sclang) and a separate audio synthesis server
(scsynth)\footnote{A multiprocessor-aware alternative to scsynth is supernova \cite{blechmann11icmc}}.


\subsection{History of SuperCollider and its Code Editing Environments}

SuperCollider is heavily influenced by Smalltalk and was originally using a similar programming model: it strongly
coupled the interpreter with the development environment. This integrated programming environment \textbf{SC.app} was
written for MacOSX using the Cocoa framework and therefore was not portable to other platforms. It provides both a
development environment and an implementation of GUI widgets.

When porting SuperCollider to Linux, Stefan Kersten implemented \textbf{scel}, a SuperCollider editor mode for Emacs
\cite{collision}, which had been the most feature-rich editor for SuperCollider for a long time, as it not only
supported syntax highlighting, but also some introspection, a limited form of call hints and support for the old
HTML-base help system.

At the moment, two other SuperCollider modes have been part of the official distribution: \textbf{scvim} (for vim) or
\textbf{sced} (for gedit). Before writing the new SuperCollider IDE, one of the authors of this paper
wrote an editor mode for Kate (\textbf{scate}). Apart from that there were other editors or editor modes,
\textbf{scfront} (a Tcl/Tk based editor), \textbf{qcollider} (a Qt-based editor) and modes for the squeak Smalltalk
environment, the TextMate editor, Eclipse and probably others \cite{collision}. For the Windows port of SuperCollider, a
python-based editor called \textbf{PsyCollider} had been developed \cite{dos}, which had been removed from the
supercollider distribution, as the code was unmaintained, unstable and it was obsolete, when GEdit/sced was ported to
Windows.

\subsection{Motivation for new IDE}

Having multiple editors or programming environments for SuperCollider has quite a lot of disadvantages:

\begin{itemize}
\item The user experience vastly differs among the different programming environments.
\item Every programming environment has to be maintained separately, while long-term maintenance turned out to be a
  problem. Especially the little development resources are spread among different projects instead on focussing on only
  one system.
\item No existing environment is working out of the box on every supported operating system.
\item Some environments like scvim or scel are based on editors that are not very accessible for beginners.
\end{itemize}

In late 2011 the authors therefore decided to start the development of a new IDE that is dedicated to SuperCollider (not
merely an editor mode). The main motivation was to provide an IDE that provides a unified user experience across all
supported platforms and that is both easy to use for beginners and powerful so that experienced users don't feel the
need to switch to an advanced editor like Emacs.

Since Jakob had already implemented the GUI widgets of sclang in Qt to make them cross-platform, the choice of the GUI
framework for the new IDE was clear.

\section{Basic architecture}

Since an IDE demands a tight integration with the target programming language, the question is
raised immediately regarding positioning of the IDE within the SuperCollider ecosystem: should it be
joined into a single process with the language interpreter, or rather a process on its own?
Previously, SC.app was the only one joined with the interpreter, while Scel, Sced, and Scate used
the interpreter as a separate child process.

Careful consideration of benefits and drawbacks of the two options brought decision in favor of
separating the IDE from the interpreter: the most important benefit of this strategy is that the
decoupling allows the IDE to survive potential crashes of the interpreter, and maintains
responsiveness and control in case running some SuperCollider code locks up in an infinite loop.

The major drawback of decoupling is increased effort for inter-process communication (IPC) with the
interpreter. However, we have minimized the need for communication by retreiving most frequently
needed information from the interpreter only once at start and caching it in a compact way within
the IDE. Moreover, we have made the IPC infrastructure generic enough to allow further extension
without much effort.

The IPC in direction from the IDE to the interpreter is based on the same principle as in Scel,
Sced and Scate. It makes use of traditional parent-to-child process communication by piping data to
child process' standard input, and relies on the interpreter's pre-existing capability to
process SuperCollider code as the input stream. The communication is thus in format of SuperCollider
code, either written and explicitly sent for evaluation by the user, or internally generated by
the IDE as a response to GUI actions.

The IPC in the other direction, however, needed to establish a dedicated channel, since the standard
output from the interpreter is already used for communication of results of code evaluation
addressed directly to the user, as opposed to data that only has purpose for internal operation of
the IDE. Similar approach has already been implemented in Scel. Our implementation is built on top
of functionality offered by Qt, which uses a local domain socket on Unix, and a named pipe on
Windows. The data is passed in YAML format.

Communication with the SuperCollider sound synthesis server takes different forms. The server is
booted and controlled via the interpreter by evaluating relevant SuperCollider code. After the
server has booted, direct communication with it is established on the basis of the server's
preexistent capability of communication using the OpenSoundControl protocol over a network
connection. The purpose is to monitor the status data sent by the server, which happens periodically
at a rather fast rate, and hence prefers more efficient and direct mode of communication.

\section{Language-related features}

\subsection{Code typing assistance}

Features that assist in code typing include those common across many IDEs: syntax highlighting,
autocompletion, and method call hints.

Syntax highlighting for SuperCollider code has been implemented already in SC.app, Scel, Sced, and
Scate. SC.app's highlighting is not performed on-the-fly while typing, but only on explicit request
via the user interface. Scel, Sced and Scate, on the other hand, have had on-the-fly highlighting
support, since they could reuse generic support for syntax highlighting of the powerful general code
editors within which they operate, by only supplying scripts describing specific syntax highlighting
rules. \emph{True for all of them?}

Despite these precedents, we have developed syntax highlighting in SuperCollider IDE from scratch.
It is written purely in C++, to ensure best performance for on-the-fly highlighting. It is performed
entirely on the basis of lexical code analysis, and attention was paid to strictly match the lexical
rules obeyed by the SuperCollider language compiler. As a result, we have most efficient and correct
syntax highlighting for SuperCollider language to-date.

Autocompletion and method call assistance has previously only been implemented in Scel. \emph{really?}
The main difficulty with these features is that they do not depend only on pre-defined lexical or
grammatical features, but on concrete available classes and their method in the SuperCollider class
library. Hence, either the development environment must parse and examine this information from the
class library files, or it must obtain it by communication with the SuperCollider language
interpreter.

\subsection{Class library browsing}

Access to SuperCollider language introspection allowed us to implement practical features for
listing of available classes, methods, as well as quickly jumping to the positions in files
where they are implemented, or referenced.

Similar feature have previously been implemented in SC.app and Scel.

\section{Help}

Details about help integration.

\section{GUI}

\begin{itemize}
 \item largely unified look across platforms
 \item general: central editor area, docks, status bar
 \item document list
 \item editor: tabs, split views, line numbering, code evaluation + blinking
 \item find/replace, regexp
 \item command line
 \item post window
 \item help
 \item server and interpreter status
 \item shortcuts
\end{itemize}

\section{Configuration}

\begin{itemize}
 \item IDE config: behavior, colors, shortcuts, etc...
 \item language config
 \item startup file
\end{itemize}


\section{Future plans}

\begin{itemize}
 \item SCDoc syntax highlighting
 \item `Desk \& cards' idea: snippets of code visually and interactively separate
 \item Visual SynthDef composer
 \item Visual Pattern composer, visualizer (integrate AlgoScore?)
 \item More integration:
 \begin{itemize}
    \item more server controls
    \item  embeddable GUI components created \& controlled in sclang
    \item  scripting (sclang? other language?)
 \end{itemize}
 \item Improved looks, QML
\end{itemize}

\section{Conclusions}

Concluding text.

\section{Acknowledgements}

Our thanks go to \ldots .

\bibliographystyle{acl}
\bibliography{sample}

\end{document}
