\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}

%opening
\title{SuperCollider IDE: A Dedicated Integrated Development Environment for SuperCollider code}
\author{Tim Blechmann, Jakob Leben}

\begin{document}

\maketitle

\begin{abstract}
In short: $SuperCollider_{2013} = kick\{ass\}$
\end{abstract}

\section{History of SuperCollider and Code Editing Environments}

Since Ice Age, SuperCollider has been slowly waking up from a dormant mode into a fully grown-up
meme monster, and by December 21 2013 it will have invaded the brains of all two-legged mammals.

\subsection{Existing IDEs}

What are SC.app, Scel, Sced, Scate?

\subsection{Motivation for new IDE}

Feed the monster.

\section{Basic architecture}

Since an IDE demands a tight integration with the target programming language, the question is
raised immediately regarding positioning of the IDE within the SuperCollider ecosystem: should it be
joined into a single process with the language interpreter, or rather a process on its own?
Previously, SC.app was the only one joined with the interpreter into a single process, while Scel,
Sced, and Scate used the interpreter as a separate child process.

Careful consideration of benefits and drawbacks of the two options brought decision in favor of
separating the IDE from the interpreter: the most important benefit of this strategy is that the
decoupling allows the IDE to survive potential crashes of the interpreter, and maintains
responsiveness and control in case running some SuperCollider code locks up in an infinite loop.

The major drawback of decoupling is increased effort for inter-process communication (IPC) with the
interpreter. However, we have minimized the need for communication by retreiving most frequently
needed information from the interpreter only once at start and caching it in a compact way within
the IDE. Moreover, we have made the IPC infrastructure generic enough to allow further extension
without much effort.

The IPC in direction from the IDE to the interpreter is based on the same principle as in Scel,
Sced and Scate. It makes use of traditional parent-to-child process communication by piping data to
child process' standard input, and relies on the interpreter's pre-existing capability to
process SuperCollider code as the input stream. The communication is thus in format of SuperCollider
code, either written and explicitly sent for evaluation by the user, or internally generated by
the IDE as a response to GUI actions.

The IPC in the other direction, however, needed to establish a dedicated channel, since the standard
output from the interpreter is already used for communication of results of code evaluation
addressed directly to the user, as opposed to data that only has purpose for internal operation of
the IDE. Similar approach has already been implemented in Scel. Our implementation is built on top
of functionality offered by Qt, which uses a local domain socket on Unix, and a named pipe on
Windows. The data is passed in YAML format.


\section{Language-related features}

\subsection{Code typing assistance}

Features that assist in code typing include those common across many IDEs: syntax highlighting,
autocompletion, and method call hints.

Syntax highlighting for SuperCollider code has been implemented already in SC.app, Scel, Sced, and
Scate. SC.app's highlighting is not performed on-the-fly while typing, but only on explicit request
via the user interface. Scel, Sced and Scate, on the other hand, have had on-the-fly highlighting
support, since they could reuse generic support for syntax highlighting of the powerful general code
editors within which they operate, by only supplying scripts describing specific syntax highlighting
rules. \emph{True for all of them?}

Despite these precedents, we have developed syntax highlighting in SuperCollider IDE from scratch.
It is written purely in C++, to ensure best performance for on-the-fly highlighting. It is performed
entirely on the basis of lexical code analysis, and attention was paid to strictly match the lexical
rules obeyed by the SuperCollider language compiler. As a result, we have most efficient and correct
syntax highlighting for SuperCollider language to-date.

Autocompletion and method call assistance has previously only been implemented in Scel. \emph{really?}
The main difficulty with these features is that they do not depend only on pre-defined lexical or
grammatical features, but on concrete available classes and their method in the SuperCollider class
library. Hence, either the development environment must parse and examine this information from the
class library files, or it must obtain it by communication with the SuperCollider language
interpreter.

\subsection{Class library browsing}

Access to SuperCollider language introspection allowed us to implement practical features for
listing of available classes, methods, as well as quickly jumping to the positions in files
where they are implemented, or referenced.

Similar feature have previously been implemented in SC.app and Scel.

\section{Help}

Details about help integration.

\section{GUI}

\begin{itemize}
 \item largely unified look across platforms
 \item general: central editor area, docks, status bar
 \item document list
 \item editor: tabs, split views, line numbering, code evaluation + blinking
 \item find/replace, regexp
 \item command line
 \item post window
 \item help
 \item server and interpreter status
 \item shortcuts
\end{itemize}

\section{Configuration}

\begin{itemize}
 \item IDE config: behavior, colors, shortcuts, etc...
 \item language config
 \item startup file
\end{itemize}


\section{Future plans}

\begin{itemize}
 \item SCDoc syntax highlighting
 \item `Desk \& cards' idea: snippets of code visually and interactively separate
 \item Visual SynthDef composer
 \item Visual Pattern composer, visualizer (integrate AlgoScore?)
 \item More integration:
 \begin{itemize}
    \item more server controls
    \item  embeddable GUI components created \& controlled in sclang
    \item  scripting (sclang? other language?)
 \end{itemize}
 \item Improved looks, QML
\end{itemize}

\end{document}
